{"repository_name":"alias_method","body":"![Alias_Method.cr CI](https://img.shields.io/github/workflow/status/wyhaines/alias_method.cr/Alias_Method.cr%20CI?style=for-the-badge&logo=GitHub)\n[![GitHub release](https://img.shields.io/github/release/wyhaines/alias_method.cr.svg?style=for-the-badge)](https://github.com/wyhaines/alias_method.cr/releases)\n![GitHub commits since latest release (by SemVer)](https://img.shields.io/github/commits-since/wyhaines/alias_method.cr/latest?style=for-the-badge)\n\n# [Alias_Method.cr](https://wyhaines.github.io/alias_method.cr/)\n\nCrystal does not natively support the creation of method aliases. This is by design, and the general philosophy of the language is that any given method should only be called by a single name.\n\nHowever, there are times when one might want to create method aliases. It is certainly possible to hand-write code to do this, but this shard provides a single-line way of aliasing a method. It works for both instance methods and for class methods.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     alias_method:\n       github: wyhaines/alias_method.cr\n   ```\n\n2. Run `shards install`\n\n## Usage\n\nSee the [complete documentation](https://wyhaines.github.io/alias_method.cr/toplevel.html) for full information on this shard and how to use it.\n\n```crystal\nrequire \"alias_method\"\n\nclass MyClass\n  def self.add(x, y)\n    x + y\n  end\n\n  def with(arg)\n    yield arg\n  end\n\n  def [](val)\n    val ** 3\n  end\n\n  def chain(ary)\n    ary << \"a\"\n  end\n\n  alias_method \"self.suma\", \"self.add\" # Class method alias\n  alias_method suma, MyClass.add       # Instance method alias to a class method\n  alias_method con, :with, 1           # Alias to a method that yields\n  alias_method cube, :[]               # Alias to a method name that has punctuation\n  alias_method nada, nothing           # Alias to a method that doesn't exist (no error)\n\n  alias_method chain_a, chain          # Create a chain of aliases\n  def chain(ary)\n    chain_a(ary) << \"b\"\n  end\n  alias_method chain_b, chain\n  def chain(ary)\n     chain_b(ary) << \"c\"\n  end\nend\n\nfoo = MyClass.new\n\nputs \"Call the MyClass.add class method via the class method alias, MyClass.suma: #{MyClass.suma(123, 456)}\"\nputs \"Call the MyClass.add class method via the instance method alias, MyClass#suma: #{foo.suma(456, 789)}\"\nputs \"Call an alias to a method that takes a block: #{foo.con(7) {|x| x ** x}}\"\nputs \"Call a method that forms a chain of aliased methods: #{foo.chain([] of String).inspect}\"\n```\n\nThe shard also implements a `remove_method` macro that can be used to (sort of) remove methods. Crystal does not actually provide any ability to truly undefine a method, so this macro redefines the removed method to throw a `NoMethodError` exception.\n\n```crystal\nclass MyClass\n  def self.add(x, y)\n    x + y\n  end\n\n  def with(arg)\n    yield arg\n  end\n\n  # Spanish translations of the method names:\n  alias_method \"suma\", \"self.add\"\n  alias_method \"con\", \"with\"\n\n  # Remove the English versions.\n  remove_method \"with\"\n  remove_method \"self.add\"\nend\n```\n\n## Benchmarks\n\nAliasing methods has no impact on performance, when compiling in release mode (in development mode, they are approximately 1/2 as fast as unaliased methods).\n\n```\n--------------------------------          \n   bare, aliased, alias 968.52M (  1.03ns) (± 2.71%)  0.0B/op        fastest\nbare, aliased, original 965.20M (  1.04ns) (± 2.67%)  0.0B/op   1.00× slower\n        bare, unaliased 965.87M (  1.04ns) (± 2.65%)  0.0B/op   1.00× slower\n--------------------------------\n   with arguments, aliased, alias 970.17M (  1.03ns) (± 2.43%)  0.0B/op        fastest\nwith arguments, aliased, original 962.70M (  1.04ns) (± 2.55%)  0.0B/op   1.01× slower\n        with arguments, unaliased 964.02M (  1.04ns) (± 2.44%)  0.0B/op   1.01× slower\n--------------------------------\n   with block, aliased, alias 966.57M (  1.03ns) (± 2.33%)  0.0B/op        fastest\nwith block, aliased, original 961.09M (  1.04ns) (± 4.18%)  0.0B/op   1.01× slower\n        with block, unaliased 966.30M (  1.03ns) (± 2.40%)  0.0B/op   1.00× slower\n--------------------------------\n   with yield, aliased, alias 968.25M (  1.03ns) (± 2.17%)  0.0B/op        fastest\nwith yield, aliased, original 966.45M (  1.03ns) (± 2.49%)  0.0B/op   1.00× slower\n        with yield, unaliased 966.61M (  1.03ns) (± 2.49%)  0.0B/op   1.00× slower\n--------------------------------\n   class method, aliased, alias 968.68M (  1.03ns) (± 2.83%)  0.0B/op        fastest\nclass method, aliased, original 966.72M (  1.03ns) (± 2.63%)  0.0B/op   1.00× slower\n        class method, unaliased 967.43M (  1.03ns) (± 2.27%)  0.0B/op   1.00× slower\n--------------------------------\n```\n\nOne interesting thing to note is that there seems to be a very slight bias in benchmark outcomes, based on the order of the code being benchmarked. In general, the first block tends to benchmark very slightly faster than the last, which means that if the order of each of the items in the benchmark is reversed, so that unaliased is first, and the aliased method is last, the above results would likely lean towards unaliased first. However, the effect is very slight. There is no appreciable difference in performance, in release mode code, between an aliased method and an unaliased method.\n\n## Development\n\nIf you wish to contribute to this shard, please fork the repository, and work from a branch within your own fork. When your work is complete (and has appropriate specs), submit a PR. Thank you!\n\n## Contributing\n\n1. Fork it (<https://github.com/wyhaines/alias_method/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Kirk Haines](https://github.com/wyhaines) - creator and maintainer\n\n![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/wyhaines/alias_method.cr?style=for-the-badge)\n![GitHub issues](https://img.shields.io/github/issues/wyhaines/alias_method.cr?style=for-the-badge)\n","program":{"html_id":"alias_method/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"alias_method","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"html_id":"alias_method(new,old,yield_arity=0,redefine=false)-macro","name":"alias_method","doc":"The `alias_method` macro is used to create method aliases.\n\nMacro arguments:\n\n* `new`: the alias; the new name for the method. This is required.\n* `old`: the original method name; this is the method that the alias will point to.\n* `yield_arity`: the expected arity of the block that the method being aliased will yield to. This argument is optional, and is only required is the aliased method yields, and the block that it yields to is expected to have an arity other than `0`.\n* `redefine`: normally, when a method is aliased for the first time, a new, canonical copy of it is created, and both the original name and the alias point to the same version of the method. If additional aliases to that same method are created, that canonical version of the method will not be redefined; all aliases will point to the same implementation. When creating alias method chains, however, the aforementioned behavior prevents the formation of a chain of method calls. Each newly created alias will point to the same method.\n\nFor example, `alias_method get, :[]` creates an alias from the `[]()` method to\nthe `get()` method.\n\nThe methods to be aliased can be specified as symbol literals, string literals, or\nvia direct method references. The macro will not throw any errors if the method\nbeing aliased can not be found.For example, consider the following examples:\n\n```\nclass MyClass\n  def self.add(x, y)\n    x + y\n  end\n\n  def with(arg)\n    yield arg\n  end\n\n  def [](val)\n    val ** 3\n  end\n\n  def chain(ary)\n    ary << \"a\"\n  end\n\n  alias_method \"self.suma\", \"self.add\" # Class method alias\n  alias_method suma, MyClass.add       # Instance method alias to a class method\n  alias_method con, :with, 1           # Alias to a method that yields\n  alias_method cube, :[]               # Alias to a method name that has punctuation\n  alias_method nada, nothing           # Alias to a method that doesn't exist (no error)\n\n  alias_method chain_a, chain          # Create a chain of aliases\n  def chain(ary)\n    chain_a(ary) << \"b\"\n  end\n  alias_method chain_b, chain\n  def chain(ary)\n     chain_b(ary) << \"c\"\n  end\nend\n\nfoo = MyClass.new\n\nputs \"Call the MyClass.add class method via the class method alias, MyClass.suma: #{MyClass.suma(123, 456)}\"\nputs \"Call the MyClass.add class method via the instance method alias, MyClass#suma: #{foo.suma(456, 789)}\"\nputs \"Call an alias to a method that takes a block: #{foo.con(7) {|x| x ** x}}\"\nputs \"Call a method that forms a chain of aliased methods: #{foo.chain([] of String).inspect}\"\n\n```\n","summary":"<p>The <code><a href=\"toplevel.html#alias_method%28new%2Cold%2Cyield_arity%3D0%2Credefine%3Dfalse%29-macro\">alias_method</a></code> macro is used to create method aliases.</p>","abstract":false,"args":[{"name":"new","doc":null,"default_value":"","external_name":"new","restriction":""},{"name":"old","doc":null,"default_value":"","external_name":"old","restriction":""},{"name":"yield_arity","doc":null,"default_value":"0","external_name":"yield_arity","restriction":""},{"name":"redefine","doc":null,"default_value":"false","external_name":"redefine","restriction":""}],"args_string":"(new, old, yield_arity = 0, redefine = false)","args_html":"(new, old, yield_arity = <span class=\"n\">0</span>, redefine = <span class=\"n\">false</span>)","location":{"filename":"src/alias_method.cr","line_number":74,"url":"https://github.com/wyhaines/alias_method.cr/blob/d478a1e3f6b532f751a5f5ab22ea993e24cbee79/src/alias_method.cr#L74"},"def":{"name":"alias_method","args":[{"name":"new","doc":null,"default_value":"","external_name":"new","restriction":""},{"name":"old","doc":null,"default_value":"","external_name":"old","restriction":""},{"name":"yield_arity","doc":null,"default_value":"0","external_name":"yield_arity","restriction":""},{"name":"redefine","doc":null,"default_value":"false","external_name":"redefine","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"  \n{% method_name = nil\nif old.class_name == \"Call\"\n  if old.receiver.is_a?(Nop)\n    receiver = @type\n  else\n    receiver = old.receiver.resolve.class\n  end\n  method_name = old.name\nelse\n  if old.includes?(\".\")\n    receiver_name, method_name = old.split(\".\")\n    if receiver_name == \"self\"\n      receiver = @type.class\n    else\n      receiver = nil\n      search_paths = [@top_level]\n      unless receiver_name[0..1] == \"::\"\n        search_paths << @type.class\n      end\n      search_paths.each do |search_path|\n        unless receiver\n          found_the_receiver = true\n          parts = receiver_name.split(\"::\")\n          parts.each do |part|\n            if found_the_receiver\n              constant_id = search_path.constants.find do |c|\n                c.id == part\n              end\n              if !constant_id\n                found_the_receiver = false\n              else\n                search_path = search_path.constant(constant_id)\n                if search_path.nil?\n                  found_the_receiver = false\n                end\n              end\n            end\n          end\n          if found_the_receiver\n            receiver = search_path.class\n          end\n        end\n      end\n    end\n  else\n    receiver = @type\n    method_name = old\n  end\nend\nnew_method_name = nil\nif new.class_name == \"Call\"\n  if new.receiver.is_a?(Nop)\n    new_receiver = @type\n  else\n    new_receiver = new.receiver.resolve.class\n  end\n  new_method_name = new.name\nelse\n  if new.includes?(\".\")\n    new_receiver_name, new_method_name = new.split(\".\")\n    if new_receiver_name == \"self\"\n      new_receiver = @type.class\n    else\n      new_receiver = nil\n      search_paths = [@top_level]\n      unless receiver_name[0..1] == \"::\"\n        search_paths << @type.class\n      end\n      search_paths.each do |search_path|\n        unless new_receiver\n          found_the_new_receiver = true\n          parts = new_receiver_name.split(\"::\")\n          parts.each do |part|\n            if found_the_new_receiver\n              constant_id = search_path.constants.find do |c|\n                c.id == part\n              end\n              if !constant_id\n                found_the_new_receiver = false\n              else\n                search_path = search_path.constant(constant_id)\n                if search_path.nil?\n                  found_the_new_receiver = false\n                end\n              end\n            end\n          end\n          if found_the_new_receiver\n            new_receiver = search_path.class\n          end\n        end\n      end\n    end\n  else\n    new_receiver = @type\n    new_method_name = new\n  end\nend\nnew_name = nil\nmethods = receiver ? receiver.methods.select do |m|\n  m.name.id == method_name\nend : [] of Nil\n %}\n\n  \n{% for method in methods %}\n  {% skip_origin = false\nif ann = method.annotation(AliasMethod::Alias)\n  if ann[:parent]\n    skip_origin = true\n    new_name = ann[:parent]\n  end\nend\nmethod_args = method.args\nmethod_arg_names = method.args.map do |__arg0|\n  __arg0.name.id\nend\nblock_arg_arity = nil\nblock_arg_ary = [] of String\nblock_arg_list = \"\"\nblock_call_list = \"\"\nblock_type = nil\nif method.accepts_block?\n  if method.block_arg\n    block_arg = \"&#{method.block_arg.id}\".id\n    block_arg_name = \"&#{method.block_arg.name.id}\"\n    method_args << block_arg\n    method_arg_names << block_arg_name\n    block_type = \"block\"\n  else\n    block_arg = nil\n    block_arg_name = nil\n    block_type = \"yield\"\n  end\n  left = ((method.block_arg.id.gsub(/[\\w\\d_]+\\s+:\\s+.\\s*/, \"\")).split(\"->\"))[0].id\n  block_arg_arity = block_type == \"block\" ? (  (left.split(\",\")).reject(&.empty?).size - 1) : (  yield_arity - 1)\n  if block_arg_arity > -1\n    letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    (0..block_arg_arity).each do |n|\n      block_arg = \"\"\n      work = n\n      block_arg = letters[work % 26]\n      work = (work // 26) - 1\n      (0..3).each do\n        if work >= 0\n          block_arg = letters[work % 26] + block_arg\n          work = (work // 26) - 1\n        end\n      end\n      block_arg_ary << block_arg\n    end\n    block_call_list = (block_arg_ary.join(\", \")).id\n    block_arg_list = \"|#{block_call_list}|\"\n  end\nend\nunless new_name\n  new_name = \"#{method.name.id}_#{method.column_number}X#{method.line_number}\"\n  {lxesxs: /\\s*\\<\\s*/, exqualxs: /\\s*\\=\\s*/, exxclamatioxn: /\\s*\\!\\s*/, txildxe: /\\s*\\~\\s*/, gxreatexr: /\\s*\\>\\s*/, pxluxs: /\\s*\\+\\s*/, mxinuxs: /\\s*\\-\\s*/, axsterisxk: /\\s*\\*\\s*/, sxlasxh: /\\s*\\/\\s*/, pxercenxt: /\\s*\\%\\s*/, axmpersanxd: /\\s*\\&\\s*/, qxuestioxn: /\\s*\\?\\s*/, lxbrackext: /\\s*\\[\\s*/, rxbrackext: /\\s*\\]\\s*/}.each do |label, punctuation|\n    new_name = new_name.gsub(punctuation, label.stringify)\n  end\nend\nalias_method_call = [receiver == @type ? \"\".id : \"#{(receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id, new_name.id, !method_args.empty? ? \"(\".id : \"\".id, (method_arg_names.join(\", \")).id, !method_args.empty? ? \")\".id : \"\".id, method.accepts_block? && (block_type == \"yield\") ? \"{#{block_arg_list.id} yield(#{block_call_list.id})}\".id : \"\".id].join(\"\")\nfqnn = [@type ? \"\".id : \"#{(receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id, new_name.id].join(\"\")\n %}\n\n  {% if redefine || (!skip_origin) %}\n  # Original method recreation, under a new name.\n  {{ method.visibility.id == \"public\" ? \"\".id : method.visibility.id }} def {{ receiver == @type ? \"\".id : \"#{(receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id }}{{ new_name.id }}{{ !method_args.empty? ? \"(\".id : \"\".id }}{{ (method_args.join(\", \")).id }}{{ !method_args.empty? ? \")\".id : \"\".id }}{{ method.return_type.id != \"\" ? \" : #{method.return_type.id}\".id : \"\".id }}\n  {{ method.body }}\n  end\n\n  # Create the aliases.\n  @[AliasMethod::Alias(parent: {{ fqnn }})]\n  {{ method.visibility.id == \"public\" ? \"\".id : method.visibility.id }} def {{ new_receiver == @type ? \"\".id : \"#{(new_receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id }}{{ method_name.id }}{{ !method_args.empty? ? \"(\".id : \"\".id }}{{ (method_args.join(\", \")).id }}{{ !method_args.empty? ? \")\".id : \"\".id }}{{ method.return_type.id != \"\" ? \" : #{method.return_type.id}\".id : \"\".id }}\n    # Rewrite the original method.\n    {{ alias_method_call.id }}\n  end\n  {% end %}\n\n  @[AliasMethod::Alias(parent: {{ fqnn }})]\n  {{ method.visibility.id == \"public\" ? \"\".id : method.visibility.id }} def {{ new_receiver == @type ? \"\".id : \"#{(new_receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id }}{{ new_method_name.id }}{{ !method_args.empty? ? \"(\".id : \"\".id }}{{ (method_args.join(\", \")).id }}{{ !method_args.empty? ? \")\".id : \"\".id }}{{ method.return_type.id != \"\" ? \" : #{method.return_type.id}\".id : \"\".id }}\n    # And write the alias method.\n    {{ alias_method_call.id }}\n  end\n\n  {% end %}\n\n  \n{% if flag?(:DEBUG)\n  debug\nend %}\n\n\n"}},{"html_id":"remove_method(old)-macro","name":"remove_method","doc":"This macro removes a method. It is not possible to actually undefined\na method in Crystal, so this macro redefines the method to return, at\nruntime, a NoMethodError exception.\n\nMethod removal works on both class methods and instance methods.\nIf you have a method chain that has been created through multiple layers\nof methods, and one of the links in the middle of the chain is removed,\nit will break the chain, so be careful with that.\n\nMethods to be removed can be specified directly, through StringLiterals,\nor through Symbol literals, just like alias_method.\n\n```crystal\nclass Foo\n  def original_method\n    \"do method stuff\"\n  end\n\n  alias_method dup_original_method, original_method\n  alias_method copy_original_method, original_method\n  alias_method extra_original_method, original_method\n\n  # Use a naked method name:\n  remove_method original_method\n\n  # Use a string:\n  remove_method \"extra_original_method\"\n\n  # Use a symbol:\n  remove_method :copy_original_method\n```\n\nThis can be convenient when aliasing class methods.\n\n```crystal\nmodule Benchmark\n  alias_method \"self.instructions_per_second\", \"self.ips\"\nend\n```","summary":"<p>This macro removes a method.</p>","abstract":false,"args":[{"name":"old","doc":null,"default_value":"","external_name":"old","restriction":""}],"args_string":"(old)","args_html":"(old)","location":{"filename":"src/alias_method.cr","line_number":384,"url":"https://github.com/wyhaines/alias_method.cr/blob/d478a1e3f6b532f751a5f5ab22ea993e24cbee79/src/alias_method.cr#L384"},"def":{"name":"remove_method","args":[{"name":"old","doc":null,"default_value":"","external_name":"old","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"  \n{% method_name = nil\nif old.class_name == \"Call\"\n  if old.receiver.is_a?(Nop)\n    receiver = @type\n  else\n    receiver = old.receiver.resolve.class\n  end\n  method_name = old.name\nelse\n  if old.includes?(\".\")\n    receiver_name, method_name = old.split(\".\")\n    if receiver_name == \"self\"\n      receiver = @type.class\n    else\n      receiver = nil\n      search_paths = [@top_level]\n      unless receiver_name[0..1] == \"::\"\n        search_paths << @type.class\n      end\n      search_paths.each do |search_path|\n        unless receiver\n          found_the_receiver = true\n          parts = receiver_name.split(\"::\")\n          parts.each do |part|\n            if found_the_receiver\n              constant_id = search_path.constants.find do |c|\n                c.id == part\n              end\n              if !constant_id\n                found_the_receiver = false\n              else\n                search_path = search_path.constant(constant_id)\n                if search_path.nil?\n                  found_the_receiver = false\n                end\n              end\n            end\n          end\n          if found_the_receiver\n            receiver = search_path.class\n          end\n        end\n      end\n    end\n  else\n    receiver = @type\n    method_name = old\n  end\nend\n %}\n\n\n  \n{% methods = receiver ? receiver.methods.select do |m|\n  m.name.id == method_name\nend : [] of Nil %}\n\n  \n{% for method in methods %}\n  {% method_args = method.args\nmethod_arg_names = method.args.map do |__arg2|\n  __arg2.name.id\nend\nif method.accepts_block? && method.block_arg\n  block_arg = \"&#{method.block_arg.id}\".id\n  block_arg_name = \"&#{method.block_arg.name.id}\"\nelse\n  block_arg = nil\n  block_arg_name = nil\nend\nif block_arg\n  method_args << block_arg\n  method_arg_names << block_arg_name\nend\n %}\n\n  # Redefine the method to simply raise.\n  {{ method.visibility.id == \"public\" ? \"\".id : method.visibility.id }} def {{ receiver == @type ? \"\".id : \"#{(receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id }}{{ method_name.id }}{{ !method_args.empty? ? \"(\".id : \"\".id }}{{ (method_args.join(\", \")).id }}{{ !method_args.empty? ? \")\".id : \"\".id }}{{ method.return_type.id != \"\" ? \" : #{method.return_type.id}\".id : \"\".id }}\n    # Rewrite the method to simply raise an undefined exception.\n    raise NoMethodError.new(\"undefined method \\`{{ method_name.id }}' for {{ @type ? @type.id : \"#{(receiver.id.gsub(/\\.class/, \"\")).gsub(/:Module/, \"\")}.\".id }}\")\n  end\n\n  {% end %}\n\n  \n{% if flag?(:DEBUG)\n  debug\nend %}\n\n\n"}}],"types":[{"html_id":"alias_method/AliasMethod","path":"AliasMethod.html","kind":"module","full_name":"AliasMethod","name":"AliasMethod","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/alias_method.cr","line_number":1,"url":"https://github.com/wyhaines/alias_method.cr/blob/d478a1e3f6b532f751a5f5ab22ea993e24cbee79/src/alias_method.cr#L1"}],"repository_name":"alias_method","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.2.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"alias_method/AliasMethod/Alias","path":"AliasMethod/Alias.html","kind":"annotation","full_name":"AliasMethod::Alias","name":"Alias","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/alias_method.cr","line_number":7,"url":"https://github.com/wyhaines/alias_method.cr/blob/d478a1e3f6b532f751a5f5ab22ea993e24cbee79/src/alias_method.cr#L7"}],"repository_name":"alias_method","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"alias_method/AliasMethod","kind":"module","full_name":"AliasMethod","name":"AliasMethod"},"doc":"When an alias is created, the macro will assign an annotation to it that\ndoes the double duty of clearly marking that a method is an alias, and also\ncarrying a pointer back to the canonical method, in the `:parent` key.","summary":"<p>When an alias is created, the macro will assign an annotation to it that does the double duty of clearly marking that a method is an alias, and also carrying a pointer back to the canonical method, in the <code>:parent</code> key.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"alias_method/NoMethodError","path":"NoMethodError.html","kind":"class","full_name":"NoMethodError","name":"NoMethodError","abstract":false,"superclass":{"html_id":"alias_method/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"alias_method/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"alias_method/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"alias_method/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/alias_method.cr","line_number":12,"url":"https://github.com/wyhaines/alias_method.cr/blob/d478a1e3f6b532f751a5f5ab22ea993e24cbee79/src/alias_method.cr#L12"}],"repository_name":"alias_method","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"This exception will be thrown if a method that has been removed via\nthe `remove_method` macro is called.","summary":"<p>This exception will be thrown if a method that has been removed via the <code><a href=\"toplevel.html#remove_method%28old%29-macro\">remove_method</a></code> macro is called.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]}}
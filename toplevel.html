<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 1.1.1">
<meta name="crystal_docs.project_version" content="main">
<meta name="crystal_docs.project_name" content="alias_method">



<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

  <meta name="repository-name" content="alias_method">
  <title>Top Level Namespace - alias_method main</title>
  <script type="text/javascript">
    CrystalDocs.base_path = "";
  </script>
</head>
<body>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>
<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          alias_method
        </a>
      </h1>

      <span class="project-version">
        main
      </span>
    </div>
  </div>

  <div class="search-results hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class=" current" data-id="alias_method/toplevel" data-name="top level namespace">
      <a href="toplevel.html">Top Level Namespace</a>
      
    </li>
  
  <li class="parent " data-id="alias_method/AliasMethod" data-name="aliasmethod">
      <a href="AliasMethod.html">AliasMethod</a>
      
        <ul>
  
  <li class=" " data-id="alias_method/AliasMethod/Alias" data-name="aliasmethod::alias">
      <a href="AliasMethod/Alias.html">Alias</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="alias_method/NoMethodError" data-name="nomethoderror">
      <a href="NoMethodError.html">NoMethodError</a>
      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1 class="type-name">

  Top Level Namespace

</h1>


















  <h2>
    <a id="defined-in" class="anchor" href="#defined-in">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Defined in:
  </h2>
  











  <h2>
    <a id="macro-summary" class="anchor" href="#macro-summary">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Macro Summary
  </h2>
  <ul class="list-summary">
    
      <li class="entry-summary">
        <a href="#alias_method%28new%2Cold%2Cyield_arity%3D0%2Credefine%3Dfalse%29-macro" class="signature"><strong>alias_method</strong>(new, old, yield_arity = <span class="n">0</span>, redefine = <span class="n">false</span>)</a>
        
          <div class="summary"><p>The <code><a href="toplevel.html#alias_method%28new%2Cold%2Cyield_arity%3D0%2Credefine%3Dfalse%29-macro">alias_method</a></code> macro is used to create method aliases.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#remove_method%28old%29-macro" class="signature"><strong>remove_method</strong>(old)</a>
        
          <div class="summary"><p>This macro removes a method.</p></div>
        
      </li>
    
  </ul>



<div class="methods-inherited">
  
</div>








  <h2>
    <a id="macro-detail" class="anchor" href="#macro-detail">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Macro Detail
  </h2>
  
    <div class="entry-detail" id="alias_method(new,old,yield_arity=0,redefine=false)-macro">
      <div class="signature">
        
        macro <strong>alias_method</strong>(new, old, yield_arity = <span class="n">0</span>, redefine = <span class="n">false</span>)

        <a class="method-permalink" href="#alias_method%28new%2Cold%2Cyield_arity%3D0%2Credefine%3Dfalse%29-macro">#</a>
      </div>
      
        <div class="doc">
          
          <p>The <code><a href="toplevel.html#alias_method%28new%2Cold%2Cyield_arity%3D0%2Credefine%3Dfalse%29-macro">alias_method</a></code> macro is used to create method aliases.</p>
<p>Macro arguments:</p>
<ul>
<li><code>new</code>: the alias; the new name for the method. This is required.</li>
<li><code>old</code>: the original method name; this is the method that the alias will point to.</li>
<li><code>yield_arity</code>: the expected arity of the block that the method being aliased will yield to. This argument is optional, and is only required is the aliased method yields, and the block that it yields to is expected to have an arity other than <code>0</code>.</li>
<li><code>redefine</code>: normally, when a method is aliased for the first time, a new, canonical copy of it is created, and both the original name and the alias point to the same version of the method. If additional aliases to that same method are created, that canonical version of the method will not be redefined; all aliases will point to the same implementation. When creating alias method chains, however, the aforementioned behavior prevents the formation of a chain of method calls. Each newly created alias will point to the same method.</li>
</ul>
<p>For example, <code>alias_method get, :[]</code> creates an alias from the <code>[]()</code> method to
the <code>get()</code> method.</p>
<p>The methods to be aliased can be specified as symbol literals, string literals, or
via direct method references. The macro will not throw any errors if the method
being aliased can not be found.For example, consider the following examples:</p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">MyClass</span>
  <span class="k">def</span> <span class="m">self</span>.add(x, y)
    x <span class="o">+</span> y
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">with</span>(arg)
    <span class="k">yield</span> arg
  <span class="k">end</span>

  <span class="k">def</span> <span class="o">[]</span>(val)
    val <span class="o">**</span> <span class="n">3</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">chain</span>(ary)
    ary <span class="o">&lt;&lt;</span> <span class="s">&quot;a&quot;</span>
  <span class="k">end</span>

  alias_method <span class="s">&quot;self.suma&quot;</span>, <span class="s">&quot;self.add&quot;</span> <span class="c"># Class method alias</span>
  alias_method suma, <span class="t">MyClass</span>.add       <span class="c"># Instance method alias to a class method</span>
  alias_method con, <span class="n">:with</span>, <span class="n">1</span>           <span class="c"># Alias to a method that yields</span>
  alias_method cube, <span class="n">:[]</span>               <span class="c"># Alias to a method name that has punctuation</span>
  alias_method nada, nothing           <span class="c"># Alias to a method that doesn&#39;t exist (no error)</span>

  alias_method chain_a, chain          <span class="c"># Create a chain of aliases</span>
  <span class="k">def</span> <span class="m">chain</span>(ary)
    chain_a(ary) <span class="o">&lt;&lt;</span> <span class="s">&quot;b&quot;</span>
  <span class="k">end</span>
  alias_method chain_b, chain
  <span class="k">def</span> <span class="m">chain</span>(ary)
     chain_b(ary) <span class="o">&lt;&lt;</span> <span class="s">&quot;c&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>

foo <span class="o">=</span> <span class="t">MyClass</span>.<span class="k">new</span>

puts <span class="s">&quot;Call the MyClass.add class method via the class method alias, MyClass.suma: </span><span class="i">#{</span><span class="t">MyClass</span>.suma(<span class="n">123</span>, <span class="n">456</span>)<span class="i">}</span><span class="s">&quot;</span>
puts <span class="s">&quot;Call the MyClass.add class method via the instance method alias, MyClass#suma: </span><span class="i">#{</span>foo.suma(<span class="n">456</span>, <span class="n">789</span>)<span class="i">}</span><span class="s">&quot;</span>
puts <span class="s">&quot;Call an alias to a method that takes a block: </span><span class="i">#{</span>foo.con(<span class="n">7</span>) {<span class="o">|</span>x<span class="o">|</span> x <span class="o">**</span> x<span class="i">}</span><span class="s">}&quot;</span>
puts <span class="s">&quot;Call a method that forms a chain of aliased methods: </span><span class="i">#{</span>foo.chain(<span class="o">[]</span> <span class="k">of</span> <span class="t">String</span>).inspect<span class="i">}</span><span class="s">&quot;</span>
</code></pre>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/wyhaines/alias_method.cr/blob/814c81ce05529d0f5b683675dbc65b852710736d/src/alias_method.cr#L74" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="remove_method(old)-macro">
      <div class="signature">
        
        macro <strong>remove_method</strong>(old)

        <a class="method-permalink" href="#remove_method%28old%29-macro">#</a>
      </div>
      
        <div class="doc">
          
          <p>This macro removes a method. It is not possible to actually undefined
a method in Crystal, so this macro redefines the method to return, at
runtime, a NoMethodError exception.</p>
<p>Method removal works on both class methods and instance methods.
If you have a method chain that has been created through multiple layers
of methods, and one of the links in the middle of the chain is removed,
it will break the chain, so be careful with that.</p>
<p>Methods to be removed can be specified directly, through StringLiterals,
or through Symbol literals, just like alias_method.</p>
<pre><code class="language-crystal"><span class="k">class</span> <span class="t">Foo</span>
  <span class="k">def</span> <span class="m">original_method</span>
    <span class="s">&quot;do method stuff&quot;</span>
  <span class="k">end</span>

  alias_method dup_original_method, original_method
  alias_method copy_original_method, original_method
  alias_method extra_original_method, original_method

  <span class="c"># Use a naked method name:</span>
  remove_method original_method

  <span class="c"># Use a string:</span>
  remove_method <span class="s">&quot;extra_original_method&quot;</span>

  <span class="c"># Use a symbol:</span>
  remove_method <span class="n">:copy_original_method</span></code></pre>
<p>This can be convenient when aliasing class methods.</p>
<pre><code class="language-crystal"><span class="k">module</span> <span class="t">Benchmark</span>
  alias_method <span class="s">&quot;self.instructions_per_second&quot;</span>, <span class="s">&quot;self.ips&quot;</span>
<span class="k">end</span></code></pre>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/wyhaines/alias_method.cr/blob/814c81ce05529d0f5b683675dbc65b852710736d/src/alias_method.cr#L395" target="_blank">View source</a>]
        
      </div>
    </div>
  


</div>

</body>
</html>
